%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% GenerateSDEPaths.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Generate multiple partial or full paths
% generated by stochastic differential equation.

function paths = GenerateSDEPaths(sde, icdf, numpaths, numYears, stepsPerYear, startvals, optParams)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Expecting following required inputs:
% -sde: function handle for target stochastic differential equation.
% Must have handle @(currlevel, iids, stepsPerYear).
% -icdf: Inverse cumulative distribution function to map uniform iids to 
% distribution for path generation. Has handle @(val, mean, sigma).
% -numpaths: Number of paths to generate.
% -numsteps: Number of steps for each path.
% -startvals: Starting values for first step.
% Optional Parameters:
% -optParams: Struct with following members:
%   *.fullpaths: Put false if only want final values.
%   *.numiids: Put integer indicating dimension of iids to generate.

hasOptParams = true;
try
   val = optParams;
catch err
    hasOptParams = false;
end

if nargin < 5
    error('sde, icdf, numpaths, numsteps, and startvals are required.')
end

numsteps = numYears * stepsPerYear;
dt = numYears / stepsPerYear;
paths = [transpose(1:numsteps) zeros(numsteps, numpaths)];

for path = 1 : numpaths
    rng shuffle;
    if hasOptParams == true
       iids = arrayfun(@(x) icdf(x), rand(numsteps,optParams.numiids)); 
    else
       iids = arrayfun(@(x) icdf(x), rand(numsteps,1)); 
    end
    for step = 1 : numsteps
        if step ~= 1
            paths(step, path + 1) = sde(paths(step - 1, path + 1), iids(step,:), dt);
        else
            paths(step, path + 1) = sde(startvals, iids(step,:), dt);
        end
    end
end

% Only return final values if fullpaths marked false:
if hasOptParams && optParams.fullpaths == false
   paths = paths(numsteps, :);
end

end